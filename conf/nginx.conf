user    nginx;
worker_processes    1;
pid     /var/run/nginx.pid;
daemon  off;

env SUPERVISOR_DEBUG;

# Send logs to stderr
error_log /dev/stderr warn;

events {
    worker_connections  1024;
}

http {
    server_names_hash_bucket_size 128;
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format simple '$remote_addr [$time_local] "$request" $status $body_bytes_sent "$http_referer"';
    access_log /dev/stdout simple;

    server {
        listen 80;
        server_name _; # This is just an invalid value which will never trigger on a real hostname.

        location / {


          rewrite_by_lua_block {
            function dirname(str)
              if str:match(".-/.-") then
                local name = string.gsub(str, "(.*/)(.*)", "%1")
                return name
              else
                return ''
              end
            end
            function file_exists(name)
               local f=io.open(name,"r")
               if f~=nil then
                io.close(f)
                return true
              else
                return false
              end
            end
            if (tonumber(os.getenv("SUPERVISOR_DEBUG")) > 0) then
              ngx.log(ngx.STDERR, "DEBUG: ngx.var.http_host = " .. ngx.var.http_host)
            end
            local handle = assert(io.popen("grep -l -F " .. ngx.var.http_host .. " /projects/*/docker-compose.yml | head -c -1", "r"))
            local dc_file = handle:read('*all')
            handle:close()
            local lock_file = dirname(dc_file) .. ".lock"
            if (tonumber(os.getenv("SUPERVISOR_DEBUG")) > 0) then
              ngx.log(ngx.STDERR, "DEBUG: lock_file = " .. lock_file)
            end
            if (dc_file ~= nil) then
              if (tonumber(os.getenv("SUPERVISOR_DEBUG")) > 0) then
                ngx.log(ngx.STDERR, "DEBUG: dc_file = " .. dc_file)
                ngx.log(ngx.STDERR, "DEBUG: Is lockfile exists: " .. tostring(file_exists(lock_file)))
              end
              if (file_exists(lock_file) == false) then
                io.popen("sudo /usr/local/bin/start_project.sh \"" .. dc_file .. "\"")
                ngx.header.content_type = 'text/html';
                res = ngx.location.capture("/refresh.html");
                ngx.print(res.body)
                ngx.exit(ngx.HTTP_OK)
              else
                ngx.header.content_type = 'text/html';
                res = ngx.location.capture("/refresh.html");
                ngx.print(res.body)
                ngx.exit(ngx.HTTP_OK)
              end
            else
              ngx.exit(ngx.HTTP_GONE)
            end
          }

        }

        location = /refresh.html {
          root /var/www/proxy;
          try_files $uri /refresh.html;
        }

    }

    # If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
    # scheme used to connect to this server
    map $http_x_forwarded_proto $proxy_x_forwarded_proto {
      default $http_x_forwarded_proto;
      ''      $scheme;
    }

    # If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
    # Connection header that may have been passed to this server
    map $http_upgrade $proxy_connection {
      default upgrade;
      '' close;
    }

    # HTTP 1.1 support
    proxy_http_version  1.1;
    proxy_buffering     off;
    proxy_set_header    Host $http_host;
    proxy_set_header    Upgrade $http_upgrade;
    proxy_set_header    Connection $proxy_connection;
    proxy_set_header    X-Real-IP $remote_addr;
    proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header    X-Forwarded-Proto $proxy_x_forwarded_proto;

    # Allow large POSTs
    client_max_body_size 500M;
    # Allow long running scripts
    proxy_read_timeout 600s;

    # Fixes random issues with POST requests
    # See https://github.com/dockerfile/nginx/issues/4#issuecomment-209440995
    client_body_temp_path /tmp 1 2;
    client_body_buffer_size 256k;
    client_body_in_file_only off;

    include /etc/nginx/conf.d/*.conf;
}
